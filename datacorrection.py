# -*- coding: utf-8 -*-
"""DataCorrection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1z7Peui4sSfpHYfFY9kFokhqPsJGD1vLq
"""

from astropy import visualization as aviz
from astropy.nddata.blocks import block_reduce
from astropy.nddata.utils import Cutout2D
from matplotlib import pyplot as plt
from astropy import units as u
from ccdproc import ImageFileCollection
from pathlib import Path
import os
from astropy.nddata import CCDData
from astropy.visualization import hist
import ccdproc as ccdp
import numpy as np
from astropy.io import fits
import astropy
from astropy.stats import mad_std
import shutil
import warnings
# Filter out the specific FITSFixedWarning
warnings.filterwarnings('ignore', category=astropy.wcs.FITSFixedWarning)

"""# 1. Import data"""

#data directories
data_dir = "/home/fmahnken/PycharmProjects/data/2023-08-11" #hier ändern für anderes programm
snapshot_dir = os.path.join(data_dir, "SNAPSHOT")
bias_dir = os.path.join(data_dir, "BIAS")
dark_dir = os.path.join(data_dir, "DARK")
flat_dir = os.path.join(data_dir, "FLAT")
light_dir = os.path.join(data_dir, "LIGHT")

# setting path for just masters and corrected
master_dir = Path(data_dir, 'Masters')
master_dir.mkdir(exist_ok=True)
dark_cor_dir = Path(data_dir, 'dark_cor')
dark_cor_dir.mkdir(exist_ok=True)
flat_cor_dir = Path(data_dir, 'flat_cor')
flat_cor_dir.mkdir(exist_ok=True)
light_cor_dir = Path(data_dir, 'light_cor')
light_cor_dir.mkdir(exist_ok=True)

#creating picture dictonaries
flat_collection= ccdp.ImageFileCollection(flat_dir)
dark_collection= ccdp.ImageFileCollection(dark_dir)
bias_collection= ccdp.ImageFileCollection(bias_dir)
snapshot_collection= ccdp.ImageFileCollection(snapshot_dir)
light_collection= ccdp.ImageFileCollection(light_dir)

def show_image(image,
               percl=99, percu=None, is_mask=False,
               figsize=(10, 10),
               cmap='viridis', log=False, clip=True,
               show_colorbar=True, show_ticks=True,
               fig=None, ax=None, input_ratio=None):

    if percu is None: # determine percentile range of the stretch
        percu = percl
        percl = 100 - percl
    if (fig is None and ax is not None) or (fig is not None and ax is None):
        raise ValueError('Must provide both "fig" and "ax" '
                         'if you provide one of them')
    elif fig is None and ax is None:
        if figsize is not None:
            # Rescale the fig size to match the image dimensions, roughly
            image_aspect_ratio = image.shape[0] / image.shape[1]
            figsize = (max(figsize) * image_aspect_ratio, max(figsize))
        fig, ax = plt.subplots(1, 1, figsize=figsize)

    fig_size_pix = fig.get_size_inches() * fig.dpi
    ratio = (image.shape // fig_size_pix).max()
    if ratio < 1:
        ratio = 1
    ratio = input_ratio or ratio
    reduced_data = block_reduce(image, ratio)

    # pecifie whether input image is a mask
    if not is_mask:
         reduced_data = reduced_data / ratio**2

    extent = [0, image.shape[1], 0, image.shape[0]]

    if log:
        stretch = aviz.LogStretch()
    else:
        stretch = aviz.LinearStretch()

    norm = aviz.ImageNormalize(reduced_data,
                               interval=aviz.AsymmetricPercentileInterval(percl, percu),
                               stretch=stretch, clip=clip)
    # mask: image that is used to identify and exclude certain regions or objects from further analysis

    if is_mask:
        # The image is a mask in which pixels should be zero or one.
        # block_reduce may have changed some of the values, so reset here.
        reduced_data = reduced_data > 0
        # Set the image scale limits appropriately.
        scale_args = dict(vmin=0, vmax=1)
    else:
        scale_args = dict(norm=norm)

    im = ax.imshow(reduced_data, origin='lower',
                   cmap=cmap, extent=extent, aspect='equal', **scale_args)

    if show_colorbar:
        fig.colorbar(im, ax=ax, fraction=0.046, pad=0.04)

    if not show_ticks:
        ax.tick_params(labelbottom=False, labelleft=False, labelright=False, labeltop=False)

"""# 2. Combine and get master values of bias, dark and flatfield

## 2.1 Bias
"""

# combine all biases to master bias
biases = bias_collection.files_filtered(imagetyp='BIAS', include_path=True)
biases = [CCDData.read(biases[i], unit='adu')for i in range(len(os.listdir(bias_dir)))] #für alle elemente in bias dir
master_bias = ccdp.combine(biases,method='median',sigma_clip=True, sigma_clip_low_thresh=5, sigma_clip_high_thresh=5,sigma_clip_func=np.ma.median, signma_clip_dev_func=mad_std,mem_limit=350e6)
master_bias.write(master_dir / 'master_bias.fit', overwrite=True)

# visual comparison between bias and master-bias
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(20, 10))
show_image(biases[0].data, cmap='gray', ax=ax1, fig=fig)
ax1.set_title('Single calibrated bias')
show_image(master_bias.data, cmap='gray', ax=ax2, fig=fig)
ax2.set_title('{} bias images combined to masterbias'.format(len(biases)))



"""## 2.2 darks"""

calibrated_darks = dark_collection.files_filtered(imagetyp='DARK', include_path=True)
calibrated_darks = [CCDData.read(calibrated_darks[i], unit='adu') for i in range(len(calibrated_darks))]
# create path for corrected darks
dark_cor_dir = Path(data_dir, 'dark_cor')

# subtracting master bias from darks
for i, ccd in enumerate(calibrated_darks):
    ccd = ccdp.subtract_bias(ccd, master_bias)     # Subtract bias
    ccd.write(dark_cor_dir / f'calibrated_{ccd.header["imagetyp"]}_{ccd.header["object"]}_{ccd.header["exptime"]:.2f}s_{i}.fit', overwrite=True)

reduced_images_dark_corrected = ccdp.ImageFileCollection(dark_cor_dir)
calibrated_darks_corrected = reduced_images_dark_corrected.files_filtered(imagetyp='DARK', include_path=True)
calibrated_darks_corrected = [CCDData.read(calibrated_darks_corrected[i], unit='adu')for i in range(len(os.listdir(dark_cor_dir)))]

# combine all bisas corrected darks to one master dark
darks = reduced_images_dark_corrected.summary['imagetyp'] == 'DARK'
dark_times = set(reduced_images_dark_corrected.summary['exptime'][darks])

for exp_time in sorted(dark_times):
    combined_dark = ccdp.combine(calibrated_darks_corrected,method='median',sigma_clip=True, sigma_clip_low_thresh=5, sigma_clip_high_thresh=5, sigma_clip_func=np.ma.median, signma_clip_dev_func=mad_std, mem_limit=350e6)
    combined_dark.meta['combined'] = True
    combined_dark.write(master_dir / 'master_dark.fit'.format(exp_time), overwrite=True)

# visual comparison between dark image and corrected dark image
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(20, 10))
show_image(calibrated_darks[0].data, cmap='gray', ax=ax1, fig=fig)
ax1.set_title('Single dark image pre calibration')
show_image(calibrated_darks_corrected[0].data, cmap='gray', ax=ax2, fig=fig)
ax2.set_title('Single calibrated dark image')

# visual comparison between dark and master-dark
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(20, 10))
show_image(calibrated_darks_corrected[0].data, cmap='gray', ax=ax1, fig=fig)
ax1.set_title('Single calibrated dark')
show_image(combined_dark.data, cmap='gray', ax=ax2, fig=fig)
ax2.set_title('{} dark images combined'.format(len(calibrated_darks)))

"""## 2.3 Flatfields"""

#make list with just flats
#flat_collection= ccdp.ImageFileCollection(flat_dir)
calibrated_flats = flat_collection.files_filtered(imagetyp='FLAT', include_path=True)
calibrated_flats = [CCDData.read(calibrated_flats[i], unit='adu')for i in range(len(os.listdir(flat_dir)))]

calibrated_path_flat_corrected = Path(data_dir, 'flat_cor')

#substract master-bias
for i, ccd in enumerate(calibrated_flats):


    # Subtract bias
    ccd = ccdp.subtract_bias(ccd, master_bias)
    # Save the result
    ccd.write(calibrated_path_flat_corrected / f'Flats{i}.fit', overwrite=True)

# useful function if there is more than one master-dark to correct flat frames
def find_nearest_dark_exposure(image, dark_exposure_times, tolerance):
    dark_exposures = np.array(list(dark_exposure_times))
    idx = np.argmin(np.sum(np.abs(dark_exposures - image.header['EXPOSURE'])))
    closest_dark_exposure = dark_exposures[idx]

    if (tolerance is not None and
        np.abs(image.header['exptime'] - closest_dark_exposure) > tolerance):

        raise RuntimeError('Closest dark exposure time is {} for flat of exposure '
                           'time {}.'.format(closest_dark_exposure, image.header['exptime']))


    return closest_dark_exposure

#substracting master-dark
for i, ccd in enumerate(calibrated_flats):

    # Find the correct dark exposure
    #print(actual_exposure_times)
    trivial_exposer_time = set([1.0]) # only have one dark exp.time set
    closest_dark = find_nearest_dark_exposure(ccd, trivial_exposer_time, None)

    # Subtract the dark current
    ccd = ccdp.subtract_dark(ccd, combined_dark, exposure_time='EXPTIME', exposure_unit=u.second, scale=True)
    # Subtract dark
    #ccd = ccdp.subtract_dark(ccd, combined_dark, dark_exposure=closest_dark)

    # Save the result
    ccd.write(calibrated_path_flat_corrected / f'Flats{i}.fit', overwrite=True)

#make list with just corrected flats
reduced_images_flat_corrected = ccdp.ImageFileCollection(calibrated_path_flat_corrected)
calibrated_flats_corrected = reduced_images_flat_corrected.files_filtered(imagetyp='FLAT', include_path=True)
calibrated_flats_corrected = [CCDData.read(calibrated_flats_corrected[i], unit='adu')for i in range(len(os.listdir(calibrated_path_flat_corrected)))]

# visual comparison between flat image and corrected flat image
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(20, 10))

show_image(calibrated_flats[0].data, cmap='gray', ax=ax1, fig=fig)
ax1.set_title('Single flat image pre calibration')
show_image(calibrated_flats_corrected[0].data, cmap='gray', ax=ax2, fig=fig)
ax2.set_title('Single calibrated flat image')

# combining flats to master-flat
def inv_median(a):
    return 1 / np.median(a)
combined_flat = ccdp.combine(calibrated_flats_corrected,method='median', scale=inv_median, sigma_clip=True, sigma_clip_low_thresh=5, sigma_clip_high_thresh=5,sigma_clip_func=np.ma.median, signma_clip_dev_func=mad_std,mem_limit=350e6)

combined_flat.meta['combined'] = True

combined_flat.write(master_dir / 'combined_flat.fit', overwrite=True)

# visual comparison between flat and master-flat
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(20, 10))

show_image(calibrated_flats_corrected[3].data, cmap='gray', ax=ax1, fig=fig)
ax1.set_title('Single calibrated flat')
show_image(combined_flat.data, cmap='gray', ax=ax2, fig=fig)
ax2.set_title('{} flat images combined to masterflat'.format(len(calibrated_darks)))

"""# 3. Image correction"""

# make a list with just light images using collection defined in 1.
calibrated_lights = light_collection.files_filtered(imagetyp='LIGHT', include_path=True)
calibrated_lights = [CCDData.read(calibrated_lights[i], unit='adu')for i in range(len(os.listdir(light_dir)))]

# making list with masters
reduced_images_masters = ccdp.ImageFileCollection(master_dir)
calibrated_masters = reduced_images_masters.files_filtered( include_path=True)
print (calibrated_masters)
#calibrated_masters = [CCDData.read(calibrated_masters[i], unit='adu')for i in range(len(os.listdir(master_dir)))]
calibrated_masters = [CCDData.read(file_path, unit='adu') for file_path in calibrated_masters]

light= light_dir

calibrated_path_light_corrected = Path(data_dir, 'light_cor')

all_reds = []
light_ccds = []
for i, ccd in enumerate(calibrated_lights):
    light_ccds.append(light)

    # Note that the first argument in the remainder of the ccdproc calls is the *reduced* image, so that the calibration steps are cumulative.
    ccd = ccdp.subtract_bias(ccd, master_bias)

    closest_dark = find_nearest_dark_exposure(ccd,  [1.0], None)
    ccd = ccdp.subtract_dark(ccd, combined_dark, exposure_time='EXPTIME', exposure_unit=u.second)
    #ccd = ccdp.subtract_dark(ccd, CCDData.read(combined_dark, unit='adu'),exposure_time='EXPTIME', exposure_unit=u.second)
    filter_indices = {'R (Johnson)': 0, 'G': 1, 'B': 2} #### andere filter noch hinzufügen
    flat_index = filter_indices[ccd.header['filter']]

    flat_data = combined_flat[flat_index]
    ccd = ccdp.flat_correct(ccd, combined_flat)

    #ccd = ccdp.flat_correct(ccd, good_flat)

    all_reds.append(ccd)

    ccd.write(calibrated_path_light_corrected / f'calibrated_{ccd.header["imagetyp"]}_{ccd.header["object"]}_{ccd.header["exptime"]:.2f}s_{i}.fit', overwrite=True)

# only final science images
reduced_images_light_corrected = ccdp.ImageFileCollection(calibrated_path_light_corrected)
calibrated_lights_corrected = reduced_images_light_corrected.files_filtered(imagetyp='LIGHT', include_path=True)
calibrated_lights_corrected = [CCDData.read(calibrated_lights_corrected[i], unit='adu')for i in range(len(os.listdir(light_cor_dir)))]

# visual comparison between light image and corrected light image
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(20, 10))

show_image(calibrated_lights[6].data, cmap='gray', ax=ax1, fig=fig)
ax1.set_title('Single light image pre calibration')
show_image(calibrated_lights_corrected[18].data, cmap='gray', ax=ax2, fig=fig)
ax2.set_title('Single calibrated light image')
plt.show()



#deleting the unusefull images to save storage
shutil.rmtree(master_dir)
shutil.rmtree(dark_cor_dir)
shutil.rmtree(flat_cor_dir)

