# -*- coding: utf-8 -*-
"""Photoutils_apperatur_phot_firsttry.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1u5bq0M-zu9dcjnn7hlMPte1--9C9EyWc

https://photutils.readthedocs.io/en/stable/aperture.html
"""

pip install photutils

import numpy as np
import matplotlib.pyplot as plt
from photutils.aperture import CircularAperture
from photutils.aperture import aperture_photometry
from photutils.aperture import ApertureStats, CircularAperture
from photutils.detection import DAOStarFinder
from photutils.datasets import make_100gaussians_image
from photutils.detection import find_peaks
from astropy.io import fits
from astropy.visualization import SqrtStretch
from astropy.stats import sigma_clipped_stats
from astropy.visualization.mpl_normalize import ImageNormalize
from astropy.visualization import simple_norm
import sys
sys.path.append('/content/drive/MyDrive/ColabNotebooks/')
import plotting

path= '/content/drive/MyDrive/ColabNotebooks/data/2023-09-11/stacked/lightCor_HIP100587_focused_B (Johnson)_2.0s_0.fit'
hdul = fits.open(path)
data= hdul[0].data
header = hdul[0].header
#plotting.show_image(data)

mean, median, std = sigma_clipped_stats(data, sigma=3.0)
print((mean, median, std))
daofind = DAOStarFinder(fwhm=3.0, threshold=10.0*std) #use high threshold to include only brighter stars. default was 5
mask = np.zeros(data.shape, dtype=bool)
mask[0:200,1900:2048] = True
sources = daofind(data - median, mask=mask) #use median as background
for col in sources.colnames:
    if col not in ('id', 'npix'):
        sources[col].info.format = '%.2f'  # for consistent table output
sources.sort(['xcentroid','ycentroid']) #sort by y coordinate (needed for fwhm later)
sources.pprint(max_width=76)
#sources.show_in_notebook() # to show all
positions = np.transpose((sources['xcentroid'], sources['ycentroid']))

apertures = CircularAperture(positions, r=10.0)
norm = ImageNormalize(stretch=SqrtStretch())
plotting.show_image(data)
apertures.plot(color='red', lw=1.0, alpha=0.5);

# with individual apperatures:
def determine_fwhm(positions):
    fwhm = []
    x_values = [int(value[0]) for value in positions]
    y_values = [int(value[1]) for value in positions]
    for i in range(len(positions)):
        row_values = data[x_values[i]-10:x_values[i]+10, y_values[i]]
        x_coordinates = range(len(row_values))
        row_values_bkg=row_values+np.median(row_values)
        half_max = (np.max(row_values_bkg) / 2)  # halfmax + background
        print(half_max)
        above_half_max_indices = np.where(row_values > half_max)[0]
        lower_index = above_half_max_indices[0]
        upper_index = above_half_max_indices[-1]
        x_lower = x_coordinates[lower_index]
        x_upper = x_coordinates[upper_index]
        fwhm.append(x_upper - x_lower)
        plt.plot(x_coordinates, row_values)
        plt.scatter([x_lower, x_upper], [half_max, half_max], color='red', label='Half-Maximum Points')
    return fwhm

fwhm= determine_fwhm(positions[26:27])
print(fwhm)

y_values = [int(value[1]) for value in positions]
x_values = [int(value[0]) for value in positions]
def determine_fwhm(y_coordinates):
    fwhm = []
    for y_coordinate in y_coordinates:
        y_index = int(round(y_coordinate))
        row_values = data[y_index, :] #müsste es nciht [:,y_index sein]?
        x_coordinates = range(len(row_values))
        max_pixel_value = np.max(row_values)
        half_max = max_pixel_value / 2
        above_half_max_indices = np.where(row_values > half_max)[0]
        lower_index = above_half_max_indices[0]
        upper_index = above_half_max_indices[-1]
        x_lower = x_coordinates[lower_index]
        x_upper = x_coordinates[upper_index]
        fwhm.append(x_upper - x_lower)
    return fwhm

fwhm= determine_fwhm(y_values)

for i in range (len(fwhm)):
  print(i,":", x_values[i], y_values[i], ":",fwhm[i])

y_positions= [tuple[1] for tuple in positions]
fwhm = determine_fwhm(y_positions)
radii = [value*3/2 for value in fwhm] #aperature size should be 3*fwhm/2
radii = [min(radius, 100) for radius in radii] #set limit to eliminate errors
print(radii)

#apertures = CircularAperture(positions, r=10.0)
norm = ImageNormalize(stretch=SqrtStretch())
plotting.show_image(data)

apertures_list = []

# Create individual apertures and add them to the list
for i in range(len(positions)):
    aperture = CircularAperture(positions[i], r=radii[i])
    apertures_list.append(aperture)

for aperture in apertures_list:
    aperture.plot(color='red', lw=1.0, alpha=0.5)


'''
apertures = [CircularAperture(positions, r=r) for r in radii]
for i in range (len(apertures)):
  apertures[i].plot(color='red', lw=1.0, alpha=0.5); #the ';' at end for not printing. lw:linewidth, alpha: transparency
'''

from google.colab import drive
drive.mount('/content/drive')



phot_table = aperture_photometry(data, apertures, method='subpixel', #subpixel divides pixels into (here 25) subpixels (increase precision, take longer)
                                 subpixels=5)
phot_table['aperture_sum'].info.format = '%.8g'  # for consistent table output
print(phot_table)



'''
#with all aperatures same size
path= "/content/drive/MyDrive/ColabNotebooks/data/2023-08-11/lightCor/lightCor_10.0_0.fit"
#path="/content/drive/MyDrive/ColabNotebooks/data/2023-08-23/lightCor/lightCor_30.0_0.fit"
#positions = [(1037.9,1575.4),(729.4,1493.8), (1724.2,1356.0),(25.3,584.3),(1677.1,648.8)] ##[(x1,y1),(x2,y2),...]
positions = [(1037.9,1575.4),(729.4,1493.8), (1724.2,1356.0),(25.3,584.3),(1677.1,648.8),(994,1005)] #with bright star (last)
aperture = CircularAperture(positions, r=15.0)
'''
phot_table = aperture_photometry(data, aperture, method='subpixel', #subpixel divides pixels into (here 25) subpixels (increase precision, take longer)
                                 subpixels=5)
phot_table['aperture_sum'].info.format = '%.8g'  # for consistent table output
print(phot_table)

'''
parameters for id 1 form ds9:
reg	sum		error	area		surf_bri		surf_err
				(pix**2)		(sum/pix**2)		(sum/pix**2)
---	---		-----	--------		------------		------------
1	396723.69		629.86	840		472.29		0.749833

reg	sum	npix	mean	median	min	max	var	stddev	rms
---	---	----	----	------	---	---	---	------	---
1	396723.69	840	472.29	416.771	327.544	1738.27	33538	183.134	506.553
'''

# with individual apperatures:
def determine_fwhm(y_coordinates):
    fwhm = []
    for y_coordinate in y_coordinates:
        y_index = int(round(y_coordinate))
        row_values = data[y_index, :] #müsste es nciht [:,y_index sein]?
        x_coordinates = range(len(row_values))
        max_pixel_value = np.max(row_values)
        half_max = max_pixel_value / 2
        above_half_max_indices = np.where(row_values > half_max)[0]
        lower_index = above_half_max_indices[0]
        upper_index = above_half_max_indices[-1]
        x_lower = x_coordinates[lower_index]
        x_upper = x_coordinates[upper_index]
        fwhm.append(x_upper - x_lower)
    return fwhm

y_positions= [tuple[1] for tuple in positions]
fwhm = determine_fwhm(y_positions)
radii = [value*3/2 for value in fwhm] #aperature size should be 3*fwhm/2
print(radii)
apertures = [CircularAperture(positions, r=r) for r in radii]

phot_table = aperture_photometry(data, apertures)
for col in phot_table.colnames:
    phot_table[col].info.format = '%.8g'
print(phot_table)

_, median, _ = sigma_clipped_stats(data, sigma=3.0)
print(median) #this is rougly the background (confirmend by ds9)
bkg=median
#data-=bkg #substract background

"""# Diff Phot

m= -2.5log((count-background)/exptime)*gain)
"""

def Magnitude(counts):
  return -2.5*np.log10((counts-bkg)/(exptime))

magnitudes_stars =[Magnitude(flux) for flux in phot_table['aperture_sum_5']]
for i in range (len(magnitudes_stars)):
  print(f'differential magnitudes for companion star {i+1} and bright star: {magnitudes_stars[5]-magnitudes_stars[i]}')