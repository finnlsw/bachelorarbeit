# -*- coding: utf-8 -*-
"""stackImagesFinal.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gxRychKf8nEqPvP0SSLvw_Waa3JRetA5
"""

import numpy as np
from matplotlib import pyplot as plt
from astropy.io import fits
import glob
import os
import cv2
import sys
from astropy import visualization as aviz
from astropy.nddata.blocks import block_reduce
from google.colab import drive
drive.mount('/content/drive')





input_path = "/content/drive/MyDrive/ColabNotebooks/data/2023-09-11/lightsCor"
input_files = glob.glob(os.path.join(input_path, 'lightCor_HIP100587_focused_I (Johnson)_*.fit'))
input_files2 = glob.glob(os.path.join(input_path, 'lightCor_HIP100587_focused_H-alpha_*.fit'))
input_files3 = glob.glob(os.path.join(input_path, 'lightCor_HIP100587_focused_R Johnson_*.fit'))
input_files4 = glob.glob(os.path.join(input_path, 'lightCor_HIP100587_focused_B (Johnson)_*.fit'))
input_file_list= [input_files,input_files2,input_files3,input_files4]

def show_image(image,
               percl=99, percu=None, is_mask=False,
               figsize=(10, 10),
               cmap='gray', log=False, clip=True,
               show_colorbar=True, show_ticks=True,
               fig=None, ax=None, input_ratio=None):
    if percu is None: # determine percentile range of the stretch
        percu = percl
        percl = 100 - percl
    if (fig is None and ax is not None) or (fig is not None and ax is None):
        raise ValueError('Must provide both "fig" and "ax" '
                         'if you provide one of them')
    elif fig is None and ax is None:
        if figsize is not None:
            image_aspect_ratio = image.shape[0] / image.shape[1]
            figsize = (max(figsize) * image_aspect_ratio, max(figsize))
        fig, ax = plt.subplots(1, 1, figsize=figsize)
    fig_size_pix = fig.get_size_inches() * fig.dpi
    ratio = (image.shape // fig_size_pix).max()
    if ratio < 1:
        ratio = 1
    ratio = input_ratio or ratio
    reduced_data = block_reduce(image, ratio)
    if not is_mask:
         reduced_data = reduced_data / ratio**2
    extent = [0, image.shape[1], 0, image.shape[0]]
    if log:
        stretch = aviz.LogStretch()
    else:
        stretch = aviz.LinearStretch()
    norm = aviz.ImageNormalize(reduced_data,
                               interval=aviz.AsymmetricPercentileInterval(percl, percu),
                               stretch=stretch, clip=clip)
    if is_mask:
        reduced_data = reduced_data > 0
        scale_args = dict(vmin=0, vmax=1)
    else:
        scale_args = dict(norm=norm)
    im = ax.imshow(reduced_data, origin='lower',
                   cmap=cmap, extent=extent, aspect='equal', **scale_args)
    if show_colorbar:
        fig.colorbar(im, ax=ax, fraction=0.046, pad=0.04)
    if not show_ticks:
        ax.tick_params(labelbottom=False, labelleft=False, labelright=False, labeltop=False)


def save_image(imageList,headerList, output_path):
    #output_path = os.path.join(curpath, "lightCor")
    if not os.path.exists(output_path):
        os.makedirs(output_path)
    # Ensure that imageList and headerList are lists (needed for single images)
    if not isinstance(imageList, list):
        imageList = [imageList]
    if not isinstance(headerList, list):
        headerList = [headerList]
    for i in range (len(imageList)):
        image=imageList[i].astype(np.float32)
        header=headerList[i]
        filename = f"lightCor_{header['OBJECT']}_{header['FILTER']}_{header['EXPTIME']}s_{i}.fit"
        fits_path = os.path.join(output_path, filename)
        hdu = fits.PrimaryHDU(image, header=header)  # Use the stored header
        hdul = fits.HDUList([hdu])
        hdul.writeto(fits_path, overwrite=True)
        hdul.close()
        if i %50 == 0:
           print(i)
    print(f"Number of files saved: {i+1}")


def stack_images(inputPath, exptime):
    # import images
    imageList = []
    headerList = []
    for file in inputPath:
        hdul = fits.open(file)
        header = hdul[0].header
        image = hdul[0].data
        if header['EXPTIME'] == exptime:
            imageList.append(image)
            headerList.append(header)
        hdul.close()
    print('number of images to stack:', len(imageList))

    # stacking
    middle_index = len(imageList) // 2
    reference_image = imageList[middle_index].astype(np.float32)
    aligned_images = [reference_image]
    warp_mode = cv2.MOTION_TRANSLATION
    warp_matrix = np.eye(2, 3, dtype=np.float32)
    criteria = (cv2.TERM_CRITERIA_EPS | cv2.TERM_CRITERIA_COUNT, 1000,
                1e-5)  # 1000: max number of iterations, 1: epsilon(desired accuracy)
    for i, image in enumerate(imageList):
        if i == middle_index:
            continue
        image = image.astype(np.float32)
        _, warp_matrix = cv2.findTransformECC(reference_image, image, warp_matrix, warp_mode, criteria)
        aligned_image = cv2.warpAffine(image, warp_matrix, reference_image.shape[::-1],
                                       flags=cv2.INTER_LINEAR + cv2.WARP_INVERSE_MAP)
        aligned_images.append(aligned_image)
        if i % 10 == 0:
            print('number of processed images:', i)
    final_stacked_image = np.median(aligned_images, axis=0)
    return final_stacked_image, headerList[0]

stackedImage, stackedHeader = stack_images(input_file_list[3], 2.0)

show_image(stackedImage)

output_path = '/content/drive/MyDrive/ColabNotebooks/data/2023-09-11/stacked'
save_image(stackedImage, stackedHeader, output_path)

'''
stackedImageList = []
stackedHeaderList = []
for wantedFile in input_file_list:
    stackedImage, stackedHeader = stack_images(wantedFile, 1.0)
    stackedImageList.append(stackedImage)
    stackedHeaderList.append(stackedHeader)


fig, ax = plt.subplots(1,3)
for i in range (len(stackedImageList)):
  ax[i]=show_image(stackedImageList[i])


output_path = '/content/drive/MyDrive/ColabNotebooks/data/2023-09-11/stacked'
save_image(stackedImageList, stackedHeaderList, output_path)
'''

